# 硬币找零问题：动态规划解法与实现

在组合数学与算法优化领域，硬币找零问题是一个经典的动态规划应用场景。该问题要求我们计算用无限数量的给定面额硬币组成特定金额的所有可能组合方式。本文将深入探讨多种解决方案，并通过实际案例解析不同算法的时间复杂度与空间优化技巧。

---

## 核心问题解析

给定包含不同面额的硬币数组`coins[]`和目标金额`sum`，我们需要找出所有可能的组合方式（不考虑顺序）。例如，当`sum=4`且`coins=[1,2,3]`时，存在以下4种组合：
- [1,1,1,1]
- [1,1,2]
- [2,2]
- [1,3]

### 关键限制条件
- 硬币可重复使用（无限供应）
- 组合不区分顺序（[1,2,1]与[1,1,2]视为同一种组合）
- 结果需排除无法达成目标金额的情况（如`sum=5`且`coins=[4]`）

---

## 算法实现路径

### 1. 递归暴力解法
通过穷举每个硬币的使用与否，建立递归关系式：
```text
count(coins, n, sum) = count(coins, n, sum - coins[n-1]) + count(coins, n-1, sum)
```
**实现逻辑：**
- 包含当前硬币：`sum - coins[n-1]`
- 排除当前硬币：`n-1`

**时间复杂度：** O(2^sum)  
**空间复杂度：** O(sum)

> 👉 [动态规划进阶指南](https://bit.ly/okx_welcome)

**示例代码：**
```python
def count_ways_recursive(coins, n, sum):
    if sum == 0:
        return 1
    if n == 0 or sum < 0:
        return 0
    return count_ways_recursive(coins, n, sum - coins[n-1]) + count_ways_recursive(coins, n-1, sum)
```

---

### 2. 顶部向下动态规划（记忆化搜索）

通过建立二维备忘录优化重复子问题计算：
```python
memo[i][j] = 前i个硬币组成金额j的组合数
```

**优化步骤：**
1. 创建`(n+1) x (sum+1)`二维数组
2. 存储已计算的子问题结果
3. 递归调用时优先查询备忘录

**时间复杂度：** O(n*sum)  
**空间复杂度：** O(n*sum)

---

### 3. 底部向上动态规划（表格填充法）

通过迭代方式构建DP表格：
```python
dp[i][j] = dp[i][j-coins[i-1]] + dp[i-1][j]
```

**表格构建规则：**
| 硬币数 | 金额0 | 金额1 | 金额2 | ... | 金额sum |
|-------|-------|-------|-------|-----|---------|
| 0     | 1     | 0     | 0     | ... | 0       |
| 1     | 1     | 1     | 1     | ... | 1       |
| 2     | 1     | 1     | 2     | ... | ...     |
| ...   | ...   | ...   | ...   | ... | ...     |
| n     | 1     | ...   | ...   | ... | 最终结果|

> 👉 [掌握交易策略优化技巧](https://bit.ly/okx_welcome)

**实现优势：**
- 消除递归栈溢出风险
- 更直观的计算过程可视化

---

### 4. 空间优化动态规划

通过观察状态转移方程，发现当前状态仅依赖：
- 同一行前一状态（包含当前硬币）
- 上一行相同状态（排除当前硬币）

**优化方案：**
- 使用一维数组`dp[sum+1]`
- 正向遍历硬币，反向更新金额

**时间复杂度：** O(n*sum)  
**空间复杂度：** O(sum)

```python
def count_ways_optimized(coins, sum):
    dp = [0] * (sum + 1)
    dp[0] = 1  # 基例：金额0只有1种组合方式
    for coin in coins:
        for j in range(coin, sum + 1):
            dp[j] += dp[j - coin]
    return dp[sum]
```

---

## 常见问题解答

**Q1：递归方法与动态规划的核心区别？**  
A：递归通过函数调用树实现自顶向下分解，动态规划通过表格或数组存储中间结果实现自底向上计算，避免重复运算。

**Q2：如何选择最优算法？**  
A：当`sum`较小时（<1000）可使用递归；大规模数据推荐空间优化DP，兼顾时间和空间效率。

**Q3：动态规划中的状态转移方程如何推导？**  
A：从最后一步决策入手，分析包含当前硬币与排除当前硬币两种情况的组合数之和。

**Q4：空间优化方案为何需要正向遍历硬币？**  
A：确保每个硬币可被多次使用，反向更新金额保证每轮计算仅依赖上一轮状态。

**Q5：如何处理无法组成目标金额的情况？**  
A：初始化时设置`dp[0]=1`，最终若`dp[sum]`仍为0则表示无解。

---

## 算法对比表

| 方法               | 时间复杂度   | 空间复杂度   | 适用场景               |
|--------------------|-------------|-------------|-----------------------|
| 递归暴力解法       | O(2^sum)    | O(sum)      | sum ≤ 20 的教学演示    |
| 顶部向下DP         | O(n*sum)    | O(n*sum)    | 中等规模问题           |
| 底部向上DP         | O(n*sum)    | O(n*sum)    | 需要结果表格分析       |
| 空间优化DP         | O(n*sum)    | O(sum)      | 大规模生产环境应用     |

---

## 实际应用案例

**场景：** 某支付系统需计算用户使用不同面额优惠券的组合可能性  
**输入：** `sum=100`，`coins=[5,10,20,50]`  
**输出：** 49种组合方式  

**性能对比：**
- 递归方法：无法在合理时间完成计算